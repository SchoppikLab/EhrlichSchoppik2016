% Preprocess_bouts_by_age.m
% by David Ehrlich, April 21, 2015

% Associated with "Control of Movement Initiation Underlies the Development of Balance" 
% Ehrlich DE and Schoppik D, Curr Biol. 2017 Feb 6;27(3):334-344.

% Run this script in age-specific subfolders of the 'Raw_Behavior_Data' directory
% to preprocess raw data. Concatenates data from individual epochs (discrete periods with an
% individual larva detected in frame) across clutches and creates matrices and cell arrays
% temporally aligned to peak speed of each bout.

clear all

d = dir;
isub = [d(:).isdir]; %# returns logical vector
nameFolds = {d(isub).name}';

%% Some parameters
edge_size = 5; %number of samples to remove from the beginning and end of each vector to account for edge effects (improper detection of fish body as it leaves field of view)
samplerate = 40; %in Hz
speedThreshold = 5; %mm/s, speed threshold for identifying bouts

%% Initialize concatenating variables, described where filled
%General variables
BodyAngles = []; GrabbedTimes = [];
HeadingMatchedAngles = []; HeadingMatchedTimes = []; HeadingMatchedSpeeds = []; 
HeadingMatchedAngVels = [];

%Output variables for propulsive bouts
PropBoutTime = []; PropBoutDuration = []; PropBoutDisplacement = [];
PropBoutMaxSpd = []; PropBoutMaxAngVel = []; PropBoutPeakAngVel = [];
PropBoutIEI = []; PropBoutIEItime = []; PropBoutIEIpitch = []; 
PropBoutIEIangVel = []; PropBoutIEIangAcc = [];
PropBoutIEIalignedPitch{1} = []; PropBoutIEIalignedAngVel{1} = [];

%Output variables aligned to peak translation of propulsive bout
PropBoutAlignedTime = []; PropBoutAlignedPitch = []; PropBoutAlignedAngVel = [];
PropBoutAlignedSpeed = []; PropBoutInitPitch = []; PropBoutNetPitchChg = []; 

%% Iterate through folders corresponding to each clutch and incorporate into grouped analysis by age
for clutchFolder=1:4
    cd(nameFolds{clutchFolder+2})  

    %Run in folder containing *.dlm files generated by VerticalFish LabView file
    filenames = dir('*.dlm');
    hh = waitbar(0,['Analyzing Clutch ' num2str(clutchFolder)]);

    %% Loop through each file
    for filenum=1:length(filenames)
        %Load raw data and pre-process to parse out epochs
        raw = dlmread(filenames(filenum).name);
        analyzed = Preprocess_LabView_output(raw,filenum);
        % Loop through each epoch of the pre-processed file
        for ind=1:length(analyzed) 
            epochDur = length(analyzed(ind).y); %duration of present epoch
            %Calculate swim speed for each frame using Pythagorean theorem with
            %horizontal and vertical translation velocities
            for z = 1:epochDur-1
                swimSpeed(z) = sqrt((analyzed(ind).xvel(z))^2 + (analyzed(ind).yvel(z))^2);
            end
            % Smoothing angular velocity to de-noise               
            smoothedAngVel = smooth(analyzed(ind).angularVelocity, 3);

            %% Concatenate values for each frame while cycling through each epoch 
            GrabbedTimes(end+1:end+length(analyzed(ind).absHours)) = analyzed(ind).absHours + analyzed(ind).absMins/60 + analyzed(ind).absSecs/3600; %time in hours
            BodyAngles(end+1:end+length(analyzed(ind).absOrientation)) = analyzed(ind).absOrientation;
            waitbar(((filenum-1)+(ind/length(analyzed)))/length(filenames),hh);

            %% Identify swim bouts and store peak translation speed and rotation speed             
            clear SpdWindStart SpdWindEnd;
            %find local maxima for speed above SpeedThreshold
            if max(swimSpeed(1:end-1)) >= speedThreshold %if fish swims faster than threshold
                %identify start and end of window when fish crosses threshold
                k = 1;
                SpdWindStart(1) = 1;
                while SpdWindStart(k) < epochDur-1 %for entire epoch
                    %find bout window start
                    try SpdWindEnd(k); %if there is an end to epoch 'k', advance that end if still above threshold or start a new epoch
                        %added the subsequent 'try' statement in case the end point is past the swimSpeed length. there is surely a better way to do this, but for now this fixes the problem. 
                        try swimSpeed(SpdWindEnd(k));
                            if swimSpeed(SpdWindEnd(k)) >= speedThreshold %if we are still above threshold
                                SpdWindEnd(k) = SpdWindEnd(k)+1;                %advance end of window
                            else
                                k = k+1;                                      %start a new epoch
                                SpdWindStart(k) = SpdWindEnd(k-1)+1;          %with a start immediately following previous end, to be advanced until next bout
                            end
                         catch
                            k = k+1;                                      %start a new epoch
                            SpdWindStart(k) = SpdWindEnd(k-1)+1;          %with a start immediately following previous end, to be advanced until next bout
                         end
                    catch %if there is no end to epoch 'k', advance start or make an end
                        if swimSpeed(SpdWindStart(k)) < speedThreshold %if start of window 'k' is below threshold
                            SpdWindStart(k) = SpdWindStart(k) + 1; %advance start of window 'k'
                        else
                            SpdWindEnd(k) = SpdWindStart(k)+1; %if start is above threshold, make an end for this threshold
                        end
                    end
                end

                %if the last value of SpdWindEnd exceeds the length of swimSpeed, set it equal to the length of swimSpeed
                try swimSpeed(SpdWindEnd(end));
                catch SpdWindEnd(end) = length(swimSpeed);
                end

                % Check if SpdWindStarts are realistically spaced to constitute separate bouts (> 100ms). 
                % If not, combine the bouts by using the first SpdWindStart and second SpdWindEnd
                % Note: manually capping detected frequency at 10Hz
                windowFrame = 1;                
                while windowFrame<length(SpdWindEnd)
                    if SpdWindStart(windowFrame+1) - SpdWindEnd(windowFrame) < (ceil(samplerate/10)) %if difference in samples is less than 100 ms
                        SpdWindEnd(windowFrame) = SpdWindEnd(windowFrame+1);
                        %delete at windowFrame+1 index
                        SpdWindStart(windowFrame+1) = [];
                        SpdWindEnd(windowFrame+1) = [];
                        windowFrame = windowFrame - 1;
                    end
                    windowFrame = windowFrame+1;
                end

                %% Isolate and analyze bouts
                BoutPairTicker = 0;
                for l=1:length(SpdWindEnd)
                    %find index for peak speed of bout
                    swimBoutPeakIndex = SpdWindStart(l)-1+find(swimSpeed(SpdWindStart(l):SpdWindEnd(l))==max(swimSpeed(SpdWindStart(l):SpdWindEnd(l)))); 
                    %define window for surrounding bout
                    boutWindowStart = swimBoutPeakIndex-ceil(0.3*samplerate);
                    boutWindowEnd = swimBoutPeakIndex+ceil(0.3*samplerate);
                    %keep within epoch
                    if boutWindowStart < 1; boutWindowStart = 1; end                
                    if boutWindowEnd > length(analyzed(ind).angularVelocity(1+edge_size:end-edge_size))-1+edge_size; boutWindowEnd = length(analyzed(ind).angularVelocity(1+edge_size:end-edge_size))-1+edge_size; end
                    %max translation speed
                    boutSwimSpdMax(l) = max(swimSpeed(SpdWindStart(l):SpdWindEnd(l)));    
                    %calculate time of bout from hours, minutes, and seconds
                    boutPeakHour(l) = analyzed(ind).absHours(swimBoutPeakIndex) + analyzed(ind).absMins(swimBoutPeakIndex)/60 + analyzed(ind).absSecs(swimBoutPeakIndex)/3600; %time in hours
                    %maximum angular velocity during bout
                    boutMaxAbsAngVel(l) = max(abs(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l))));
                    %duration and displacement of bout
                    PropBoutDuration(end+1) = (SpdWindEnd(l)-SpdWindStart(l))/samplerate; %duration above speed threshold (5 mm/sec) in seconds
                    PropBoutDisplacement(end+1) = sqrt((analyzed(ind).x(boutWindowEnd)-analyzed(ind).x(boutWindowStart))^2+(analyzed(ind).y(boutWindowEnd)-analyzed(ind).y(boutWindowStart))^2);

                    %calculate peak angular velocity of this bout (largest magnitude, nose-up or -down)
                    if abs(min(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)))) > max(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)))
                        boutPeakAngVel(l) = min(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)));
                    else boutPeakAngVel(l) = max(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)));
                    end

                    %% Record bout data aligned to propulsive peak
                    %if window is far enough from edge to allow alignment
                    %AND values during pre and post peak window are sufficiently low
                    if swimBoutPeakIndex > 30 && swimBoutPeakIndex < length(analyzed(ind).angularVelocity)-20 && min(swimSpeed(swimBoutPeakIndex-10:swimBoutPeakIndex)) < 3 && min(swimSpeed(swimBoutPeakIndex:boutWindowEnd)) < 3
                        boutAlign(l) = swimBoutPeakIndex;
                        PropBoutAlignedAngVel(end+1,1:51) = smoothedAngVel(boutAlign(l)-30:boutAlign(l)+20);
                        PropBoutAlignedSpeed(end+1,1:51) = swimSpeed(boutAlign(l)-30:boutAlign(l)+20);
                        PropBoutAlignedPitch(end+1,1:51) = analyzed(ind).absOrientation(boutAlign(l)-30:boutAlign(l)+20);
                        PropBoutInitPitch(end+1) = mean(analyzed(ind).absOrientation(boutAlign(l)-10:boutAlign(l)-5));
                        PropBoutNetPitchChg(end+1) = mean(analyzed(ind).absOrientation(boutAlign(l)+5:boutAlign(l)+10)) - PropBoutInitPitch(end);
                        AlignedTime = analyzed(ind).absHours(swimBoutPeakIndex) + analyzed(ind).absMins(swimBoutPeakIndex)/60 + analyzed(ind).absSecs(swimBoutPeakIndex)/3600; %time in hours
                        PropBoutAlignedTime(end+1) = AlignedTime - floor(AlignedTime/24)*24; %time in hours for light/dark comparison
                    end

                    clear swimBoutPeakIndex boutWindowStart boutWindowEnd;
                end

                %fill some concatenating variables
                PropBoutTime(end+1:end+l) = boutPeakHour-floor(boutPeakHour/24)*24;
                PropBoutMaxSpd(end+1:end+l) = boutSwimSpdMax;
                PropBoutMaxAngVel(end+1:end+l) = boutMaxAbsAngVel;
                PropBoutPeakAngVel(end+1:end+l) = boutPeakAngVel;

                %calculate corresponding pitch and angular velocity for inter-event intervals (IEIs)
                %include window from SpdWindEnd to next SpdWindStart padded
                %with 100msec (postBoutBuffer)
                postPeakBuffer = ceil(0.3*samplerate); %in frames   
                prePeakBuffer = ceil(0.1*samplerate);
                for IEI=1:length(SpdWindEnd)-1                
                    if length(smoothedAngVel) >= (SpdWindEnd(IEI)+postPeakBuffer) && length(smoothedAngVel) >= SpdWindStart(IEI+1)-prePeakBuffer
                        %save in output var the intervals between propulsive bouts in seconds, and time of IEI
                        PropBoutIEI(end+1) = diff(SpdWindStart(IEI:IEI+1))./samplerate; 
                        PropBoutIEItime(end+1) = PropBoutTime(end-length(SpdWindEnd)+1+IEI);
                        PropBoutIEIpitch(end+1) = mean(analyzed(ind).absOrientation(SpdWindEnd(IEI)+postPeakBuffer:SpdWindStart(IEI+1)-prePeakBuffer));
                        PropBoutIEIangVel(end+1) = mean(smoothedAngVel(SpdWindEnd(IEI)+postPeakBuffer:SpdWindStart(IEI+1)-prePeakBuffer));
                        PropBoutIEIangAcc(end+1) = mean(diff(smoothedAngVel(SpdWindEnd(IEI)+postPeakBuffer:SpdWindStart(IEI+1)-prePeakBuffer)))*samplerate;
                        PropBoutIEIalignedAngVel{end+1} = smoothedAngVel(SpdWindEnd(IEI)+ceil(0.05*samplerate):SpdWindStart(IEI+1)-prePeakBuffer);
                        PropBoutIEIalignedPitch{end+1} = analyzed(ind).absOrientation(SpdWindEnd(IEI)+ceil(0.05*samplerate):SpdWindStart(IEI+1)-prePeakBuffer);
                    end
                end

                %clear epoch-specific variables that have been concatenated
                clear boutPeakHour boutSwimSpdMax boutMaxAbsAngVel boutWindowStart boutWindowEnd boutAlignedAccel;
                clear boutMaxAbsAngVel boutPeakAngVel boutAlign boutPeakAccel boutAlignedAngVel boutAlignedSpeed;
            end

            clear SpdWindStart SpdWindEnd swimSpeed trueAngAcc baselineAngVels;
            clear epochDur;
        end

        %% grab all headings (translation directions)
        for ii=1:length(analyzed) %for every epoch
            epochDur = length(analyzed(ii).y); %duration of present epoch.
            HeadingMatchedAngles(end+1:end+epochDur-1-2*edge_size) = analyzed(ii).absOrientation(1+edge_size:end-edge_size-1);
            HeadingMatchedSpeeds(end+1:end+epochDur-1-2*edge_size) = ((analyzed(ii).xvel(1+edge_size:end-edge_size)).^2 + (analyzed(ii).yvel(1+edge_size:end-edge_size)).^2).^.5;
            HeadingMatchedAngVels(end+1:end+epochDur-1-2*edge_size) = (analyzed(ii).angularVelocity(1+edge_size:end-edge_size));
            HeadingMatchedTimes(end+1:end+epochDur-1-2*edge_size) = analyzed(ii).absHours(1+edge_size:end-edge_size-1) + analyzed(ii).absMins(1+edge_size:end-edge_size-1)/60 + analyzed(ii).absSecs(1+edge_size:end-edge_size-1)/3600;
            HeadingMatchedTimes = HeadingMatchedTimes - floor(HeadingMatchedTimes/24)*24;
        end

        %% clear epoch after analysis
        clear raw analyzed;
    end
    close(hh);
    cd ..
end

%convert PropBoutIEItime to 0-24hrs
PropBoutIEItime = PropBoutIEItime-(floor(PropBoutIEItime/24))*24;

%% save output variables
clear ans BoutPairTicker clutchFolder d edge_size epochDur filenames filenum hh IEI
clear ii ind isub k l nameFolds postPeakBuffer prePeakBuffer samplerate 
clear smoothedAngVel speedThreshold windowFrame z

currentFolder = pwd;
save(['Group_' currentFolder(end-4:end)])

    
    
    
 