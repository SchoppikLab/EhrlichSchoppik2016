% Preprocess_bouts_by_clutch_oil.m
% by David Ehrlich, April 21, 2015

% Associated with "Control of Movement Initiation Underlies the Development of Balance" 
% Ehrlich DE and Schoppik D, Curr Biol. 2017 Feb 6;27(3):334-344.

% Call this function in age-specific subfolders of the 'Raw_Behavior_Data' directory
% to preprocess raw data. In each clutch-specific folder, this function concatenates data 
% from individual epochs (discrete periods with an individual larva detected in frame) 
% and creates matrices and cell arrays temporally aligned to peak speed of each bout.

% To avoid counting passive sinking as swim bouts, this function excludes
% bouts with trajectories within 20degrees of vertical down. (see line 130)

function Preprocess_bouts_by_clutch_oil()
d = dir;
isub = [d(:).isdir]; %# returns logical vector
nameFolds = {d(isub).name}';

% Some parameters
edgesize = 5; %number of samples to remove from the beginning and end of each vector to account for edge effects (improper detection of fish body as it leaves field of view)
samplerate = 40; %in Hz
speedThreshold = 5; %mm/s, speed threshold for identifying bouts

%% Loop through folders corresponding to each clutch and analyze contents
for clutchFolder=1:length(nameFolds)-2
    cd(nameFolds{clutchFolder+2})  

    %Run in folder containing *.dlm files generated by VerticalFish LabView file
    filenames = dir('*.dlm');
    hh = waitbar(0,['Analyzing Clutch ' num2str(clutchFolder)]);

    %% Initialize concatenating variables, described where filled
    %General variables
    BodyAngles = []; GrabbedTimes = [];
    HeadingMatchedAngles = []; HeadingMatchedTimes = []; HeadingMatchedSpeeds = []; 
    HeadingMatchedAngVels = [];

    %Output variables for propulsive bouts
    PropBoutTime = []; PropBoutDuration = []; PropBoutDisplacement = [];
    PropBoutMaxSpd = []; PropBoutMaxAngVel = []; PropBoutPeakAngVel = [];
    PropBoutIEI = []; PropBoutIEItime = []; PropBoutIEIpitch = []; 
    PropBoutIEIangVel = []; PropBoutIEIangAcc = [];
    PropBoutIEIalignedPitch{1} = []; PropBoutIEIalignedAngVel{1} = [];

    %Output variables aligned to peak translation of propulsive bout
    PropBoutAlignedTime = []; PropBoutAlignedPitch = []; PropBoutAlignedAngVel = [];
    PropBoutAlignedSpeed = []; PropBoutInitPitch = []; PropBoutNetPitchChg = []; 

    %% Loop through each file
    for filenum=1:length(filenames)
        %Load raw data and pre-process to parse out epochs
        raw = dlmread(filenames(filenum).name);
        analyzed = Preprocess_LabView_output(raw,filenum);
        % Loop through each epoch of the pre-processed file
        for ind=1:length(analyzed) 
            epochDur = length(analyzed(ind).y); %duration of present epoch
            %Calculate swim speed for each frame using Pythagorean theorem with
            %horizontal and vertical translation velocities
            for z = 1:epochDur-1
                swimSpeed(z) = sqrt((analyzed(ind).xvel(z))^2 + (analyzed(ind).yvel(z))^2);
            end
            % Smoothing angular velocity to de-noise               
            smoothedAngVel = smooth(analyzed(ind).angularVelocity, 3);

            %% Concatenate values for each frame while cycling through each epoch 
            GrabbedTimes(end+1:end+length(analyzed(ind).absHours)) = analyzed(ind).absHours + analyzed(ind).absMins/60 + analyzed(ind).absSecs/3600; %time in hours
            BodyAngles(end+1:end+length(analyzed(ind).absOrientation)) = analyzed(ind).absOrientation;
            waitbar(((filenum-1)+(ind/length(analyzed)))/length(filenames),hh);

            %% Identify swim bouts and store peak translation speed and rotation speed             
            clear SpdWindStart SpdWindEnd;
            %find local maxima for speed above SpeedThreshold
            if max(swimSpeed(1:end-1)) >= speedThreshold %if fish swims faster than threshold
                %identify start and end of window when fish crosses threshold
                k = 1;
                SpdWindStart(1) = 1;
                while SpdWindStart(k) < epochDur-1 %for entire epoch
                    %find bout window start
                    try SpdWindEnd(k); %if there is an end to epoch 'k', advance that end if still above threshold or start a new epoch
                        %added the subsequent 'try' statement in case the end point is past the swimSpeed length. there is surely a better way to do this, but for now this fixes the problem. 
                        try swimSpeed(SpdWindEnd(k));
                            if swimSpeed(SpdWindEnd(k)) >= speedThreshold %if we are still above threshold
                                SpdWindEnd(k) = SpdWindEnd(k)+1;                %advance end of window
                            else
                                k = k+1;                                      %start a new epoch
                                SpdWindStart(k) = SpdWindEnd(k-1)+1;          %with a start immediately following previous end, to be advanced until next bout
                            end
                         catch
                            k = k+1;                                      %start a new epoch
                            SpdWindStart(k) = SpdWindEnd(k-1)+1;          %with a start immediately following previous end, to be advanced until next bout
                         end
                    catch %if there is no end to epoch 'k', advance start or make an end
                        if swimSpeed(SpdWindStart(k)) < speedThreshold %if start of window 'k' is below threshold
                            SpdWindStart(k) = SpdWindStart(k) + 1; %advance start of window 'k'
                        else
                            SpdWindEnd(k) = SpdWindStart(k)+1; %if start is above threshold, make an end for this threshold
                        end
                    end
                end

                %if the last value of SpdWindEnd exceeds the length of swimSpeed, set it equal to the length of swimSpeed
                try swimSpeed(SpdWindEnd(end));
                catch SpdWindEnd(end) = length(swimSpeed);
                end

                % Check if SpdWindStarts are realistically spaced to constitute separate bouts (> 100ms). 
                % If not, combine the bouts by using the first SpdWindStart and second SpdWindEnd
                % Note: manually capping detected frequency at 10Hz
                windowFrame = 1;                
                while windowFrame<length(SpdWindEnd)
                    if SpdWindStart(windowFrame+1) - SpdWindEnd(windowFrame) < (ceil(samplerate/10)) %if difference in samples is less than 100 ms
                        SpdWindEnd(windowFrame) = SpdWindEnd(windowFrame+1);
                        %delete at windowFrame+1 index
                        SpdWindStart(windowFrame+1) = [];
                        SpdWindEnd(windowFrame+1) = [];
                        windowFrame = windowFrame - 1;
                    end
                    windowFrame = windowFrame+1;
                end

                %% Isolate and analyze bouts
                BoutPairTicker = 0;
                l=1;
                while l<=length(SpdWindEnd)
                    %find index for peak speed of bout
                    swimBoutPeakIndex = SpdWindStart(l)-1+find(swimSpeed(SpdWindStart(l):SpdWindEnd(l))==max(swimSpeed(SpdWindStart(l):SpdWindEnd(l)))); 

                    %if bout is pointed approx. vertically down, exclude it
                    if atand(diff(analyzed(ind).y(swimBoutPeakIndex:swimBoutPeakIndex+1)) / abs(diff(analyzed(ind).x(swimBoutPeakIndex:swimBoutPeakIndex+1)))) < -70                        
                        SpdWindStart(l) = [];
                        SpdWindEnd(l) = [];       
                    else
                        %define window for surrounding bout
                        boutWindowStart = swimBoutPeakIndex-ceil(0.3*samplerate);
                        boutWindowEnd = swimBoutPeakIndex+ceil(0.3*samplerate);
                        %keep within epoch
                        if boutWindowStart < 1; boutWindowStart = 1; end                
                        if boutWindowEnd > length(analyzed(ind).angularVelocity(1+edgesize:end-edgesize))-1+edgesize; boutWindowEnd = length(analyzed(ind).angularVelocity(1+edgesize:end-edgesize))-1+edgesize; end
                        %max translation speed
                        boutSwimSpdMax(l) = max(swimSpeed(SpdWindStart(l):SpdWindEnd(l)));    
                        %calculate time of bout from hours, minutes, and seconds
                        boutPeakHour(l) = analyzed(ind).absHours(swimBoutPeakIndex) + analyzed(ind).absMins(swimBoutPeakIndex)/60 + analyzed(ind).absSecs(swimBoutPeakIndex)/3600; %time in hours
                        %maximum angular velocity during bout
                        boutMaxAbsAngVel(l) = max(abs(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l))));
                        %duration and displacement of bout
                        PropBoutDuration(end+1) = (SpdWindEnd(l)-SpdWindStart(l))/samplerate; %duration above speed threshold (5 mm/sec) in seconds
                        PropBoutDisplacement(end+1) = sqrt((analyzed(ind).x(boutWindowEnd)-analyzed(ind).x(boutWindowStart))^2+(analyzed(ind).y(boutWindowEnd)-analyzed(ind).y(boutWindowStart))^2);

                        %calculate peak angular velocity of this bout (largest magnitude, nose-up or -down)
                        if abs(min(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)))) > max(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)))
                            boutPeakAngVel(l) = min(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)));
                        else boutPeakAngVel(l) = max(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)));
                        end

                        %% Record bout data aligned to propulsive peak
                        %if window is far enough from edge to allow alignment
                        %AND values during pre and post peak window are sufficiently low
                        if swimBoutPeakIndex > 30 && swimBoutPeakIndex < length(analyzed(ind).angularVelocity)-20 && min(swimSpeed(swimBoutPeakIndex-10:swimBoutPeakIndex)) < 3 && min(swimSpeed(swimBoutPeakIndex:boutWindowEnd)) < 3
                            boutAlign(l) = swimBoutPeakIndex;
                            PropBoutAlignedAngVel(end+1,1:51) = smoothedAngVel(boutAlign(l)-30:boutAlign(l)+20);
                            PropBoutAlignedSpeed(end+1,1:51) = swimSpeed(boutAlign(l)-30:boutAlign(l)+20);
                            PropBoutAlignedPitch(end+1,1:51) = analyzed(ind).absOrientation(boutAlign(l)-30:boutAlign(l)+20);
                            PropBoutInitPitch(end+1) = mean(analyzed(ind).absOrientation(boutAlign(l)-10:boutAlign(l)-5));
                            PropBoutNetPitchChg(end+1) = mean(analyzed(ind).absOrientation(boutAlign(l)+5:boutAlign(l)+10)) - PropBoutInitPitch(end);
                            AlignedTime = analyzed(ind).absHours(swimBoutPeakIndex) + analyzed(ind).absMins(swimBoutPeakIndex)/60 + analyzed(ind).absSecs(swimBoutPeakIndex)/3600; %time in hours
                            PropBoutAlignedTime(end+1) = AlignedTime - floor(AlignedTime/24)*24; %time in hours for light/dark comparison
                        end

                        clear swimBoutPeakIndex boutWindowStart boutWindowEnd;
                        l = l+1; %iterate to next speed window
                    end
                end
                l = l-1; %l grows beyond number of bouts detected during iteration

                if ~isempty(SpdWindEnd) %if a bout remains in this epoch
                    %fill some concatenating variables
                    PropBoutTime(end+1:end+l) = boutPeakHour-floor(boutPeakHour/24)*24;
                    PropBoutMaxSpd(end+1:end+l) = boutSwimSpdMax;
                    PropBoutMaxAngVel(end+1:end+l) = boutMaxAbsAngVel;
                    PropBoutPeakAngVel(end+1:end+l) = boutPeakAngVel;

                    %calculate corresponding pitch and angular velocity for IEIs
                    %include window from SpdWindEnd to next SpdWindStart padded
                    %with 100msec (postBoutBuffer)
                    postPeakBuffer = ceil(0.3*samplerate); %in frames   
                    prePeakBuffer = ceil(0.1*samplerate);
                    for IEI=1:length(SpdWindEnd)-1                
                        if length(smoothedAngVel) >= (SpdWindEnd(IEI)+postPeakBuffer) && length(smoothedAngVel) >= SpdWindStart(IEI+1)-prePeakBuffer
                            %save in output var the intervals between propulsive bouts in seconds, and time of IEI
                            PropBoutIEI(end+1) = diff(SpdWindStart(IEI:IEI+1))./samplerate; 
                            PropBoutIEItime(end+1) = PropBoutTime(end-length(SpdWindEnd)+1+IEI);
                            PropBoutIEIpitch(end+1) = mean(analyzed(ind).absOrientation(SpdWindEnd(IEI)+postPeakBuffer:SpdWindStart(IEI+1)-prePeakBuffer));
                            PropBoutIEIangVel(end+1) = mean(smoothedAngVel(SpdWindEnd(IEI)+postPeakBuffer:SpdWindStart(IEI+1)-prePeakBuffer));
                            PropBoutIEIangAcc(end+1) = mean(diff(smoothedAngVel(SpdWindEnd(IEI)+postPeakBuffer:SpdWindStart(IEI+1)-prePeakBuffer)))*samplerate;
                            PropBoutIEIalignedAngVel{end+1} = smoothedAngVel(SpdWindEnd(IEI)+ceil(0.05*samplerate):SpdWindStart(IEI+1)-prePeakBuffer);
                            PropBoutIEIalignedPitch{end+1} = analyzed(ind).absOrientation(SpdWindEnd(IEI)+ceil(0.05*samplerate):SpdWindStart(IEI+1)-prePeakBuffer);
                        end
                    end

                    %clear epoch-specific variables that have been concatenated
                    clear boutPeakHour boutSwimSpdMax boutMaxAbsAngVel boutWindowStart boutWindowEnd boutAlignedAccel;
                    clear boutMaxAbsAngVel boutPeakAngVel boutAlign boutPeakAccel boutAlignedAngVel boutAlignedSpeed;
                end
            end

            clear SpdWindStart SpdWindEnd swimSpeed trueAngAcc baselineAngVels;
            clear epochDur;
        end

        %% grab all headings (translation directions)
        for ii=1:length(analyzed) %for every epoch
            epochDur = length(analyzed(ii).y); %duration of present epoch.
            HeadingMatchedAngles(end+1:end+epochDur-1-2*edgesize) = analyzed(ii).absOrientation(1+edgesize:end-edgesize-1);
            HeadingMatchedSpeeds(end+1:end+epochDur-1-2*edgesize) = ((analyzed(ii).xvel(1+edgesize:end-edgesize)).^2 + (analyzed(ii).yvel(1+edgesize:end-edgesize)).^2).^.5;
            HeadingMatchedAngVels(end+1:end+epochDur-1-2*edgesize) = (analyzed(ii).angularVelocity(1+edgesize:end-edgesize));
            HeadingMatchedTimes(end+1:end+epochDur-1-2*edgesize) = analyzed(ii).absHours(1+edgesize:end-edgesize-1) + analyzed(ii).absMins(1+edgesize:end-edgesize-1)/60 + analyzed(ii).absSecs(1+edgesize:end-edgesize-1)/3600;
            HeadingMatchedTimes = HeadingMatchedTimes - floor(HeadingMatchedTimes/24)*24;
        end

        %% clear epoch after analysis
        clear raw analyzed;
    end

    %convert PropBoutIEItime to 0-24hrs
    PropBoutIEItime = PropBoutIEItime-(floor(PropBoutIEItime/24))*24;

    close(hh);

    %% save output variables
    clear ans BoutPairTicker clutchFolder d epochDur filenames filenum hh IEI
    clear ii ind isub k l postPeakBuffer prePeakBuffer 
    clear smoothedAngVel windowFrame z

    currentFolder = pwd;
    save([currentFolder(end-6:end) '_data'])
    
    cd ..
end
end

    
    
    
 